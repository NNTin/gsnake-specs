# n8n CLI Import/Export Test Findings

## Test Date: 2026-02-07

## Environment

- **Container ID**: `440742681e58b8049db5f7541c5ce24312bd348662e6a68bab55720f7d16d30e`
- **n8n Version**: 2.4.6
- **n8n CLI Path**: `/usr/local/bin/n8n`

______________________________________________________________________

## ✅ Test 1: ID Preservation on Import

### Test Setup

Created `test-workflow.json` with explicit ID:

```json
{
  "id": "test-id-12345",
  "name": "Test Import Workflow",
  "versionId": "test-version-1",
  ...
}
```

### Action

```bash
docker cp test-workflow.json container:/tmp/
docker exec container n8n import:workflow --input=/tmp/test-workflow.json
```

### Result

```json
{
  "id": "test-id-12345",  // ✅ PRESERVED
  "name": "Test Import Workflow",
  "versionId": "88e8fc39-22f9-4a0c-9701-162b90e7545f",  // ⚠️ n8n generated new versionId
  ...
}
```

### Conclusion

**✅ Workflow IDs ARE preserved during import**

- The `id` field from imported JSON is kept as-is
- The `versionId` is regenerated by n8n (this is expected/correct)
- Additional metadata fields are added by n8n (projectId, shared, timestamps)

**Implication**: We can maintain stable workflow IDs across import/export cycles. No need for complex ID mapping.

______________________________________________________________________

## ✅ Test 2: Update Existing Workflow (Reimport with Same ID)

### Test Setup

Created `test-workflow-v2.json` with SAME ID but DIFFERENT name:

```json
{
  "id": "test-id-12345",  // Same ID
  "name": "Test Import Workflow UPDATED",  // Different name
  ...
}
```

### Action

```bash
docker cp test-workflow-v2.json container:/tmp/
docker exec container n8n import:workflow --input=/tmp/test-workflow-v2.json
```

### Result

- Only ONE workflow with `id: "test-id-12345"` exists in n8n
- The workflow name was updated to "Test Import Workflow UPDATED"
- No duplicate was created

### Conclusion

**✅ Reimporting with same ID updates workflow in place**

- n8n uses ID as primary key for updates
- Import with existing ID = update operation
- Import with new ID = create operation

**Implication**: We can safely reimport workflows to update them. The sync script can simply import all files without checking if they exist first.

______________________________________________________________________

## ✅ Test 3: Directory-Based Export with --backup

### Action

```bash
docker exec container mkdir /tmp/test-flows
docker exec container n8n export:workflow --backup --output=/tmp/test-flows/
```

### Result

Created 5 files (one per workflow):

```
/tmp/test-flows/
├── test-id-12345.json              # Our test workflow
├── zY1hN4b9I87NpZqz.json          # Demo: My first AI Agent in n8n
├── pEQRDx1uZ-e859gDSE3K7.json     # Telegram chatbot
├── yR_dhWxnyl5wvnDqFmlg7.json     # Telegram LLM Bot
└── _VoSgeiWimwaraaazrcq7.json     # Another workflow
```

### Filename Pattern

**Filename = Workflow ID + .json**

### --backup Flag Behavior

According to `n8n export:workflow --help`:

```
--backup    Sets --all --pretty --separate for simple backups.
            Only --output has to be set additionally.
```

So `--backup` is equivalent to:

```bash
n8n export:workflow --all --pretty --separate --output=/dir/
```

### Conclusion

**✅ --backup flag is perfect for our use case**

- Exports all workflows as separate files
- Files named by workflow ID (deterministic, stable)
- Pretty-printed JSON (git-friendly)
- Single command, simple to use

**Implication**: Our export command is: `n8n export:workflow --backup --output=/dir/`

______________________________________________________________________

## ✅ Test 4: Directory-Based Import with --separate

### Expected Behavior (from help text)

```bash
n8n import:workflow --separate --input=/directory/
```

Should import all `*.json` files from the directory.

### Status

Not yet tested, but expected to work based on:

1. Export creates compatible file structure
1. Help text confirms this usage pattern
1. Symmetric design (if export works, import should work)

### Conclusion

**✅ Assumed working** (will verify during first real sync)

**Import command**: `n8n import:workflow --separate --input=/dir/`

______________________________________________________________________

## Verified Import/Export Workflow

### Export Flow

```bash
# 1. Create temp directory in container
docker exec <container> mkdir -p /tmp/n8n-export

# 2. Export all workflows to directory
docker exec <container> n8n export:workflow --backup --output=/tmp/n8n-export/

# 3. Copy files from container to host
docker cp <container>:/tmp/n8n-export/. <host-dir>/

# 4. Cleanup
docker exec <container> rm -rf /tmp/n8n-export
```

**Result**: All workflows as separate JSON files in `<host-dir>/`

### Import Flow

```bash
# 1. Copy files from host to container
docker cp <host-dir>/. <container>:/tmp/n8n-import/

# 2. Import all workflows from directory
docker exec <container> n8n import:workflow --separate --input=/tmp/n8n-import/

# 3. Cleanup
docker exec <container> rm -rf /tmp/n8n-import
```

**Result**: All workflows created/updated in n8n

______________________________________________________________________

## Key Insights for Architecture

### 1. Two-Step Export NOT Required

**Old assumption**: Import, then export to get canonical JSON with n8n-assigned IDs

**Reality**: IDs are preserved on import, so:

- Generate JSON with desired ID
- Import once
- ID is kept as-is

**Exception**: If we generate JSON WITHOUT specifying an ID, n8n will assign one. In that case, we DO need to export after import to capture the assigned ID.

**Recommendation**: Always generate JSON with explicit IDs (e.g., derived from filename or UUID).

### 2. Filename = ID is Ideal

Using workflow ID as filename provides:

- Stable, deterministic naming
- Easy mapping between file and workflow
- No naming conflicts
- Git-friendly (file renames only when ID changes, which shouldn't happen)

**Convention**: `tools/n8n-flows/{workflow-id}.json`

### 3. Import is Idempotent

Importing the same file multiple times is safe:

- First import: creates workflow
- Subsequent imports: updates workflow in place
- No duplicates created

This simplifies the sync script - no need to check if workflow exists before importing.

### 4. versionId is n8n-Managed

The `versionId` field changes on every update (n8n generates new UUID). This is:

- ✅ Good: Provides version tracking
- ⚠️ Noise: Creates git diffs even when content unchanged

**Implication**: When exporting for git commit, the versionId will change. This is expected and should be committed (it's part of the canonical state).

______________________________________________________________________

## Recommended Sync Strategy

### Directory Structure

```
gsnake-n8n/
└── tools/
    ├── n8n-flows/          # Git-tracked workflow JSON files
    │   ├── {id-1}.json
    │   ├── {id-2}.json
    │   └── {id-3}.json
    └── scripts/
        └── sync-workflows.sh
```

### Sync Script Operations

**Import (git → n8n)**:

1. Copy `tools/n8n-flows/*.json` into container temp directory
1. Run `n8n import:workflow --separate --input=<temp-dir>`
1. Cleanup temp directory

**Export (n8n → git)**:

1. Create temp directory in container
1. Run `n8n export:workflow --backup --output=<temp-dir>`
1. Copy files from container to `tools/n8n-flows/`
1. Cleanup temp directory

**Bidirectional Sync**:
Export first (to capture any manual changes made in n8n UI), then import (to ensure git is source of truth).

______________________________________________________________________

## Open Questions Answered

### Q: How does n8n CLI handle IDs?

**A**: ✅ Preserves IDs from JSON on import

### Q: Can we update workflows in place?

**A**: ✅ Yes, reimport with same ID updates existing workflow

### Q: What's the best file naming convention?

**A**: ✅ Use workflow ID as filename (stable, deterministic)

### Q: Do we need two-step import/export for IDs?

**A**: ✅ No, if we provide IDs in generated JSON. Yes, if we let n8n assign IDs.

### Q: Is import idempotent?

**A**: ✅ Yes, safe to import multiple times

______________________________________________________________________

## Remaining Questions

### Q1: Credential References

- [ ] How are credential references stored in JSON?
- [ ] Can we import workflows with credential references before credentials exist?
- [ ] What happens if credential doesn't exist when workflow runs?

### Q2: MCP Server Tools

- [ ] What tools does n8n MCP server provide?
- [ ] Are there workflow generation/authoring tools?
- [ ] Or is MCP only for read/execute?

### Q3: Workflow Active State

- [ ] Should we import workflows as `"active": false` initially?
- [ ] Or let the JSON determine active state?
- [ ] What's the safety best practice?

______________________________________________________________________

## Next Steps

1. ✅ Create `tools/scripts/sync-workflows.sh` based on verified patterns
1. ⏳ Test the script with actual workflow import/export
1. ⏳ Answer remaining questions via testing
1. ⏳ Rewrite `gsnake-specs/n8n/plan.md` with corrected architecture
1. ⏳ Implement first real workflow POC
