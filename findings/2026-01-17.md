# Folder Structure Code Review

## Scope
Code folder structure only (non-markdown). Review focuses on repository layout, boundaries between subsystems, and risks tied to directory organization.

## Findings
### High
- Build artifacts and vendor dependencies are present in the repo, which bloats history and risks stale outputs: `node_modules/`, `gsnake-web/node_modules/`, `gsnake-core/target/`, `gsnake-web/dist/`, `test-results/`.
- Submodule intent is unclear vs. nested repos: `gsnake-web` is listed as a submodule but contains a full `.git/` directory, which will confuse tooling and make root-level Git operations inconsistent.

### Medium
- `gsnake-python` is declared as a submodule but only contains a `.git` pointer file and no visible code; this breaks local builds and makes the layout look incomplete without a dedicated bootstrap step.
- Duplicated toolchain config at root and inside `gsnake-core/` (`rust-toolchain.toml`, `rustfmt.toml`) creates ambiguity about which config is authoritative for contributors and CI.
- Frontend entry points are split between root and component folders (`gsnake-web/App.svelte` and `gsnake-web/components/App.svelte`) with an empty `gsnake-web/index.tsx`, which makes the app’s true entry harder to locate and maintain.

### Low
- The Rust core is nested as `gsnake-core/engine/core` while bindings live in `gsnake-core/engine/bindings/{cli,wasm}`; this is workable but the deep nesting adds path noise and slows discovery of crate boundaries.
- Shared data lives in `gsnake-core/engine/core/data/levels.json`, but there’s no obvious adjacent asset or schema folder, which makes it harder to find or validate game content conventions.






Findings

- High: UI renders stale food/obstacles because level never updates after init; the Rust engine removes food,
but the Svelte grid still reads lvl.food from the initial level. This makes eaten food persist visually and
desyncs platforms. See gsnake-web/engine/WasmGameEngine.ts:80-133, gsnake-web/stores/stores.ts:12-36, gsnake-
web/components/GameGrid.svelte:12-43.
- High: Grid is hard‑coded to 15x15 in the UI; any level with different gridSize will render incorrectly or
clip. See gsnake-web/components/GameGrid.svelte:6-66.
- Medium: Engine panics if a level has an empty snake because of unwrap()/indexing on segments[0]. There’s no
level validation layer, so a malformed level JSON can crash the WASM/CLI. See gsnake-core/engine/core/src/
engine.rs:60-81.
- Medium: Level serves as both static definition and mutable runtime state (snake + food mutate inside the
level). This makes serialization, replay, and UI mirroring harder, and leads to redundant conversions in the
web layer. See gsnake-core/engine/core/src/lib.rs:58-118, gsnake-core/engine/core/src/engine.rs:14-148.
- Low: String-based enum mapping in the JS wrapper duplicates Rust enums and status mapping; easy to drift if
you add new states/directions. See gsnake-web/engine/WasmGameEngine.ts:94-166, gsnake-core/engine/bindings/
wasm/src/lib.rs:51-63.

Open questions / assumptions

- Do you want UI rendering to be derived from the Rust Frame.grid (authoritative), or keep UI derivation with
richer runtime state (then you need to push updated level/food each move)?
- Should levels be validated at load time (bounds, overlaps, non-empty snake) or during engine creation?

Change summary (suggested architecture improvements)

- Use a single authoritative runtime model: either emit Frame from Rust and render directly from frame.grid in
the UI, or send a LevelState payload per frame (snake + food + obstacles) and stop recomputing in Svelte.
- Separate static LevelDefinition from mutable LevelState in Rust; keep LevelDefinition immutable for
serialization and use LevelState inside GameEngine.
- Add a lightweight level validation step in GameEngine::new (or parse_levels_json) to enforce invariants and
avoid panics.
- Consider exporting Rust enums to TS (via wasm-bindgen or ts-rs) to remove string mapping and keep type parity.